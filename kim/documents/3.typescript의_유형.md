# 3. typescript의 유형

### 기본 데이터 타입

```tsx
//number
let loanAmount: number = 5000000; //대출금액
let interestRate: number = 3.5; //금리

//string
let bank: string = "Kakao Bank";
let userName: string = "Jane Doe";

//boolean
let isOpen: boolean = true;
```

### 배열 (Array)

```tsx
//Type[] --> 간단한 타입
let numbers: number[] = [1, 2, 3];
let friends: string[] = ["철수", "영희"];

//Array<Type> --> 복잡한 타입
let numbers2: Array<number> = [1, 2, 3];
let friends2: Array<string> = ["철수", "영희"];
```

위는 기능적으로는 완전히 동일하게 동작하지만, 문법이 다름.

```tsx
let ages: number[] = [25, 30, 35];
let ages: Array<number> = [25, 30, 35];

let example: number[][] = [
  [1, 2],
  [3, 4],
];
let example: Array<Array<number>> = [
  [1, 2],
  [3, 4],
];

// 간단한 데이터 - Type[]
const [amounts, setAmounts] = useState<number[]>([]);
const [selectedIds, setSelectedIds] = useState<string[]>([]);

// 복잡한 타입 - Array<Type>
const [loanData, setLoanData] = useState<Array<LoanInfo>>([]);

// ReadonlyArray는 무조건 Array<> 형태만 가능
const fixedRates: ReadonlyArray<number> = [3.5, 3.8, 4.0];
// readonly number[] 도 되긴 하는데, ReadonlyArray<number>가 표준
```

### 객체 타입

```tsx
let user: {
  name: string;
  age: number;
  email?: string; // optional
} = {
  name: "김철수",
  age: 30,
};
```

### 튜플

> 정해진 개수, 정해진 순서, 정해진 타입의 배열 ex)주민번호, 좌표

```tsx
function calculateDsr(income: number, debt: number): [number, string] {
  const ratio = (debt / income) * 100;
  const status = ratio <= 40 ? "승인가능" : "승인불가";
  return [ratio, status];
}

const [dsrRatio, approvalStatus] = calculateDsr(5000000, 2000000);
console.log(`DSR: ${dsrRatio}%, 상태: ${approvalStatus}`);
```

### ENUM (열거형)

```tsx
enum DsrGrade {
  EXCELLENT = "우수", // 0-30%
  GOOD = "양호", // 30-40%
  WARNING = "주의", // 40-50%
  DANGER = "위험", // 50%+
}

function getDsrGrade(ratio: number): DsrGrade {
  if (ratio <= 30) return DsrGrade.EXCELLENT;
  if (ratio <= 40) return DsrGrade.GOOD;
  if (ratio <= 50) return DsrGrade.WARNING;
  return DsrGrade.DANGER;
}
```
