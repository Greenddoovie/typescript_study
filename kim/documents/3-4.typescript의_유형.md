# 3. typescript의 유형

### 기본 데이터 타입

```tsx
//number
let loanAmount: number = 5000000; //대출금액
let interestRate: number = 3.5; //금리

//string
let bank: string = "Kakao Bank";
let userName: string = "Jane Doe";

//boolean
let isOpen: boolean = true;
```

### 배열 (Array)

```tsx
//Type[] --> 간단한 타입
let numbers: number[] = [1, 2, 3];
let friends: string[] = ["철수", "영희"];

//Array<Type> --> 복잡한 타입
let numbers2: Array<number> = [1, 2, 3];
let friends2: Array<string> = ["철수", "영희"];
```

위는 기능적으로는 완전히 동일하게 동작하지만, 문법이 다름.

```tsx
let ages: number[] = [25, 30, 35];
let ages: Array<number> = [25, 30, 35];

let example: number[][] = [
  [1, 2],
  [3, 4],
];
let example: Array<Array<number>> = [
  [1, 2],
  [3, 4],
];

// 간단한 데이터 - Type[]
const [amounts, setAmounts] = useState<number[]>([]);
const [selectedIds, setSelectedIds] = useState<string[]>([]);

// 복잡한 타입 - Array<Type>
const [loanData, setLoanData] = useState<Array<LoanInfo>>([]);

// ReadonlyArray는 무조건 Array<> 형태만 가능
const fixedRates: ReadonlyArray<number> = [3.5, 3.8, 4.0];
// readonly number[] 도 되긴 하는데, ReadonlyArray<number>가 표준
```

### 객체 타입

```tsx
let user: {
  name: string;
  age: number;
  email?: string; // optional
} = {
  name: "김철수",
  age: 30,
};
```

### 튜플

> 정해진 개수, 정해진 순서, 정해진 타입의 배열 ex)주민번호, 좌표

```tsx
function calculateDsr(income: number, debt: number): [number, string] {
  const ratio = (debt / income) * 100;
  const status = ratio <= 40 ? "승인가능" : "승인불가";
  return [ratio, status];
}

const [dsrRatio, approvalStatus] = calculateDsr(5000000, 2000000);
console.log(`DSR: ${dsrRatio}%, 상태: ${approvalStatus}`);
```

### ENUM (열거형)

```tsx
enum DsrGrade {
  EXCELLENT = "우수", // 0-30%
  GOOD = "양호", // 30-40%
  WARNING = "주의", // 40-50%
  DANGER = "위험", // 50%+
}

function getDsrGrade(ratio: number): DsrGrade {
  if (ratio <= 30) return DsrGrade.EXCELLENT;
  if (ratio <= 40) return DsrGrade.GOOD;
  if (ratio <= 50) return DsrGrade.WARNING;
  return DsrGrade.DANGER;
}
```

# 4. type assertion

```tsx
let empty = [];

// 값이 있는 배열
let numbers = [1, 2, 3]; // number[]
let names = ["철수", "영희"]; // string[]
let mixed = [1, "hello", true]; // (number | string | boolean)[]

// 객체 배열
let users = [
  { name: "철수", age: 25 },
  { name: "영희", age: 30 },
];
// { name: string; age: number }[] 로 추론
```

타입 병시가 필요한 경우

```tsx
// 1. 함수 매개변수 (필수!)
function calculate(income: number, debt: number) {}

// 2. 빈 배열/객체
let loans: LoanInfo[] = [];
let data: Record<string, number> = {};

// 3. 복잡한 타입
interface DsrResult {
  ratio: number;
  status: string;
  grade: string;
}
let result: DsrResult | null = null;

// 4. API 응답 (타입 단언)
const response = await fetch("/api/dsr");
const data = (await response.json()) as DsrResult;

// 5. 함수 반환 타입 (명확성을 위해)
function calculateDsr(income: number, debt: number): DsrResult {}
```
