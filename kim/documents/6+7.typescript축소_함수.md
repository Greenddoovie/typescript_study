# Narrowing

-> 타입 좁히기

## instanceof

> TypeScript의 instanceof 연산자는 타입 축소에 사용되며, 객체가 특정 클래스 또는 생성자 함수의 인스턴스인지 확인할 수 있습니다. </br>
> 조건문에서 instanceof 연산자를 사용하면 TypeScript는 검사 결과에 따라 변수의 타입을 축소합니다.

### 왜 에러 타입을 구분하나요?

에러 타입을 구분하는 이유:

1. **각 에러마다 다른 처리 방법이 필요**

   - 네트워크 에러 → 재시도 가능
   - 타입 에러 → 코드 수정 필요
   - 권한 에러 → 로그인 페이지로 리다이렉트

2. **사용자에게 더 정확한 메시지 제공**

   - "네트워크 연결을 확인해주세요" vs "잘못된 입력입니다"

3. **디버깅과 로깅이 쉬워짐**

   - 어떤 종류의 에러가 많이 발생하는지 추적 가능

4. **에러 타입별로 다른 복구 전략 적용 가능**

```tsx
async function fetchUserData(userId: string) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    const data = await response.json();
    return data;
  } catch (error) {
    // ❌ 모든 에러를 똑같이 처리 (나쁜 예)
    // console.log("에러 발생:", error);
    // return null;

    // ✅ 에러 타입별로 다르게 처리 (좋은 예)
    if (error instanceof TypeError) {
      // 네트워크 에러나 잘못된 URL
      console.error("네트워크 에러:", error.message);
      // 재시도 로직 추가 가능
      throw new Error("서버에 연결할 수 없습니다. 네트워크를 확인해주세요.");
    } else if (error instanceof SyntaxError) {
      // JSON 파싱 에러
      console.error("데이터 파싱 에러:", error.message);
      throw new Error("서버 응답을 처리할 수 없습니다.");
    } else if (error instanceof Error) {
      // 일반 에러
      console.error("에러 발생:", error.message);
      throw error;
    } else {
      // 예상치 못한 에러
      console.error("알 수 없는 에러:", error);
      throw new Error("예상치 못한 오류가 발생했습니다.");
    }
  }
}
```

#### 실제 사용 예시

```tsx
// API 호출 함수
async function login(username: string, password: string) {
  try {
    const response = await fetch("/api/login", {
      method: "POST",
      body: JSON.stringify({ username, password }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    if (error instanceof TypeError) {
      // 네트워크 에러 (인터넷 연결 끊김, 서버 다운 등)
      alert("네트워크 연결을 확인해주세요.");
      // 오프라인 모드로 전환하거나 재시도 버튼 표시
    } else if (error instanceof SyntaxError) {
      // JSON 파싱 에러
      console.error("서버 응답 형식 오류");
      alert("서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
    } else if (error instanceof Error) {
      // 일반 에러 (HTTP 에러 등)
      if (error.message.includes("401")) {
        // 인증 에러
        alert("아이디 또는 비밀번호가 올바르지 않습니다.");
      } else if (error.message.includes("500")) {
        // 서버 에러
        alert("서버 오류가 발생했습니다. 관리자에게 문의해주세요.");
      } else {
        alert(error.message);
      }
    }
    throw error; // 상위로 에러 전달
  }
}
```

#### 커스텀 에러 클래스 사용

```tsx
// 커스텀 에러 클래스 정의
class NetworkError extends Error {
  constructor(message: string, public statusCode?: number) {
    super(message);
    this.name = "NetworkError";
  }
}

class ValidationError extends Error {
  constructor(message: string, public field: string) {
    super(message);
    this.name = "ValidationError";
  }
}

// 사용 예시
function processForm(data: FormData) {
  try {
    if (!data.email) {
      throw new ValidationError("이메일을 입력해주세요", "email");
    }
    // ... 처리 로직
  } catch (error) {
    if (error instanceof ValidationError) {
      // 특정 필드에 에러 표시
      console.error(`${error.field} 필드 오류: ${error.message}`);
      // UI에 해당 필드만 빨간색으로 표시
    } else if (error instanceof NetworkError) {
      // 네트워크 에러 처리
      console.error(`네트워크 에러 (${error.statusCode}): ${error.message}`);
    } else {
      // 기타 에러
      console.error("예상치 못한 에러:", error);
    }
    throw error;
  }
}
```

## typeof

`typeof`는 **두 가지 용도**로 사용됩니다:

### 1. JavaScript 런타임 `typeof` (값의 타입을 문자열로 반환)

런타임에 값의 타입을 문자열로 확인할 때 사용합니다.

```tsx
function calculate(income: string | number) {
  if (typeof income === "string") {
    // string으로 확정되면 숫자로 바꿈
    return parseFloat(income.replace(/,/g, ""));
  }
  // 여기선 자동으로 number로 확정
  return income;
}
```

### 2. TypeScript 타입 레벨 `typeof` (값의 타입을 추출)

컴파일 타임에 값의 타입을 추출하여 타입으로 사용할 때 사용합니다.

```tsx
// 타입 레벨 typeof - 컴파일 타임에만 존재
const user = {
  name: "철수",
  age: 30,
  email: "chulsoo@example.com",
};

// user의 타입을 추출
type UserType = typeof user;
// 결과: { name: string; age: number; email: string }

// 함수의 반환 타입 추출
function createUser() {
  return {
    name: "영희",
    age: 25,
  };
}

type User = ReturnType<typeof createUser>;
// 결과: { name: string; age: number }
```

#### **값에서 타입 추출 - 타입 레벨 typeof**

```tsx
// 상수 객체에서 타입 추출
const BUTTON_VARIANTS = {
  PRIMARY: "primary",
  SECONDARY: "secondary",
  DANGER: "danger",
} as const;

// typeof로 객체의 타입을 가져옴
type ButtonVariantsType = typeof BUTTON_VARIANTS;
// 결과: { readonly PRIMARY: "primary"; readonly SECONDARY: "secondary"; readonly DANGER: "danger" }

// keyof typeof로 키들의 유니온 타입 추출
type ButtonVariant = (typeof BUTTON_VARIANTS)[keyof typeof BUTTON_VARIANTS];
// 결과: "primary" | "secondary" | "danger"

// 사용 예시
interface ButtonProps {
  variant: ButtonVariant; // 정확히 3개 값 중 하나만 허용
}

function Button({ variant }: ButtonProps) {
  // variant는 "primary" | "secondary" | "danger" 중 하나
}
```

#### 3. **함수 타입 추출**

```tsx
function add(a: number, b: number): number {
  return a + b;
}

// 함수의 타입을 추출
type AddFunction = typeof add;
// 결과: (a: number, b: number) => number

// 함수의 매개변수 타입 추출
type AddParams = Parameters<typeof add>;
// 결과: [a: number, b: number]

// 함수의 반환 타입 추출
type AddReturn = ReturnType<typeof add>;
// 결과: number
```

### 런타임 typeof vs 타입 레벨 typeof 비교

```tsx
const user = { name: "철수", age: 30 };

// 1. 런타임 typeof (JavaScript)
const runtimeType = typeof user; // "object" (문자열)
console.log(runtimeType); // "object"

// 2. 타입 레벨 typeof (TypeScript)
type UserType = typeof user; // { name: string; age: number } (타입)
// 컴파일 후 JavaScript 코드에서는 완전히 사라짐!

// ❌ 타입 레벨 typeof를 런타임에서 사용할 수 없음
// const type = typeof user; // 이건 런타임 typeof임 (문자열 반환)
```

### 주의사항

1. **null의 typeof는 "object"**

   ```tsx
   typeof null === "object"; // true (주의!)
   // null 체크는 typeof 대신 직접 비교
   if (value === null) { ... }
   ```

2. **배열의 typeof도 "object"**

   ```tsx
   typeof [1, 2, 3] === "object"; // true
   // 배열 체크는 Array.isArray() 사용
   if (Array.isArray(value)) { ... }
   ```

3. **타입 레벨 typeof는 타입 위치에서만 사용**

   ```tsx
   // ✅ 타입 위치
   type User = typeof user;

   // ❌ 값 위치 (에러!)
   // const type = typeof user; // 이건 런타임 typeof
   ```

## Equality

```tsx
type CalculatorType = "dsr" | "dti" | "ltv" | "capital-gains";

function getCalculatorTitle(type: CalculatorType) {
  if (type === "dsr") {
    return "DSR 계산기";
  }
  // 나머지 타입들...
}
```

# assertion

> 권한 관련한 페이지 작업 시, 사용자의 행동제어

https://jha-memo.tistory.com/247

# typescirpt 함수

> 정확한 매개변수를 받게하는 역할

```tsx
// 계산기 함수들의 타입을 명확하게
function calculateDSR(loanPayment: number, income: number): number {
  return (loanPayment / income) * 100;
}

// 또는 함수 타입을 변수로
type CalculatorFunction = (a: number, b: number) => number;

const calculateLTV: CalculatorFunction = (loanAmount, propertyValue) => {
  return (loanAmount / propertyValue) * 100;
};
```

# 고차타입

> 타입을 받아서 새로운 타입으로 바꾸어 주는 타입

### 제네릭

> 타입의 변수

```tsx
// 어떤타입이든 배열로 반환한하는 고차타입
type WrapInArray<T> = T[];

type StringArray = WrapInArray<string>; //string[]
type NumberArray = WrapInArray<number>; //number[]

// 모든 타입을 optional로만들기
interface FormType {
  name: string;
  age: number;
  address: string;
}

//모든 필드를 optional로만드는 고차타입
type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Form = Partial<FormType>;
// 결과:
// {
//   loanAmount?: number;
//   income?: number;
//   period?: number;
// }

// 폼 초기값에 유용!
const initialForm: Form = {};

interface FormType {
  name: string;
  age: number;
  address: string;
}

// 모든 필드가 required인 경우
const initialForm1: FormType = {}; // ❌ 에러! name, age, address가 필수

// Partial을 사용하면
type Form = Partial<FormType>;
const initialForm2: Form = {}; // ✅ OK! 모든 필드가 optional이 됨
```
